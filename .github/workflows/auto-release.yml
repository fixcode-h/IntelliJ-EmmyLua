# GitHub Actions 工作流名称
name: Build and Release on Push to Main

# 触发工作流的事件
on:
  push:
    branches:
      - main # 当 main 分支有新的推送时触发

# 工作流运行的任务
jobs:
  build-and-release:
    # 使用最新的 Ubuntu 虚拟机环境
    runs-on: ubuntu-latest
    # 赋予工作流写入权限，用于创建 Release 和提交版本文件
    permissions:
      contents: write

    steps:
      # 第一步：检出代码 (fetch-depth: 0 是必须的，用于获取所有 git 历史记录)
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # 第二步：设置 Java 环境
      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'

      # 第三步：设置 Gradle 环境
      - name: Setup Gradle
        uses: gradle/actions/setup-gradle@v3

      # 第四步：计算新版本号
      # 这是核心修改步骤，用于实现版本号的自动计算和管理
      - name: Calculate New Version
        id: versioning
        run: |
          # 1. 定义跟踪文件和初始 Commit ID
          TRACKING_FILE="version.properties"
          INITIAL_COMMIT="3639f63474c46a89fb15be2bd4cc4fac356d8e8c"

          # 2. 读取上个版本信息，如果跟踪文件不存在，则使用初始值
          if [ -f "$TRACKING_FILE" ]; then
            source $TRACKING_FILE
            # 从文件加载 LAST_VERSION, LAST_COMMIT, LAST_RELEASE_DATE
            LAST_COMMIT_HASH=$LAST_COMMIT
            echo "找到版本跟踪文件. 上次发布的版本: ${LAST_VERSION}, Commit: ${LAST_COMMIT_HASH}"
          else
            # 从 plugin.xml 中提取版本号作为初始版本
            LAST_VERSION=$(grep -oP '(?<=<version>).*?(?=</version>)' plugin.xml)
            LAST_COMMIT_HASH=$INITIAL_COMMIT
            # 为了确保首次运行时年份判断正确，设置一个足够早的日期
            LAST_RELEASE_DATE="2024-01-01"
            echo "未找到版本跟踪文件. 使用初始配置. 版本: ${LAST_VERSION}, Commit: ${LAST_COMMIT_HASH}"
          fi

          # 3. 计算从上次发布以来的 commit 数量
          COMMIT_COUNT=$(git rev-list --count $LAST_COMMIT_HASH..${{ github.sha }})
          echo "从 $LAST_COMMIT_HASH 至今有 $COMMIT_COUNT 次新的提交。"
          
          # 4. 解析旧版本号
          IFS='.' read -r -a V <<< "$LAST_VERSION"
          MAJOR=${V[0]}
          MINOR=${V[1]}
          PATCH=${V[2]}

          # 5. 根据规则计算新版本号
          CURRENT_YEAR=$(date +'%Y')
          LAST_RELEASE_YEAR=$(date -d "$LAST_RELEASE_DATE" +'%Y')

          if [ "$CURRENT_YEAR" -gt "$LAST_RELEASE_YEAR" ]; then
            echo "新的一年，主版本号增加。"
            MAJOR=$((MAJOR + 1))
            MINOR=0
            PATCH=0
          else
            if [ "$COMMIT_COUNT" -gt 15 ]; then
              echo "提交数量 (>15)，中间版本号增加。"
              MINOR=$((MINOR + 1))
              PATCH=0
            else
              echo "提交数量 (<=15)，末尾版本号增加。"
              PATCH=$((PATCH + 1))
            fi
          fi

          NEW_VERSION="$MAJOR.$MINOR.$PATCH"
          echo "计算出的新版本号为: $NEW_VERSION"

          # 6. 将新版本号和上次的 commit hash 设置为环境变量和步骤输出，供后续步骤使用
          echo "NEW_VERSION=$NEW_VERSION" >> $GITHUB_ENV
          echo "LAST_COMMIT_HASH=$LAST_COMMIT_HASH" >> $GITHUB_ENV
          
      # 第五步：更新 plugin.xml 中的版本号
      # Gradle 打包时会读取这个文件，确保打包产物包含正确的版本信息
      - name: Update plugin.xml with new version
        run: |
          echo "正在将版本号更新到 plugin.xml..."
          # 使用 sed 命令查找并替换 <version> 标签内的内容
          sed -i "s|<version>.*</version>|<version>${{ env.NEW_VERSION }}</version>|" plugin.xml
          echo "plugin.xml 已更新为版本 ${{ env.NEW_VERSION }}"
          cat plugin.xml

      # 第六步：执行 Gradle 打包命令
      - name: Build with Gradle
        run: ./gradlew buildPlugin -x buildSearchableOptions

      # 第七步：生成增量的 Release 更新日志
      - name: Generate release notes
        id: generate_notes
        run: |
          # 1. 从上次发布的 commit 开始，生成本次的提交日志
          LOG_CONTENT=$(git log ${{ env.LAST_COMMIT_HASH }}..${{ github.sha }} --pretty=format:'* %s (%h)')

          # 2. 检查日志是否为空
          if [ -z "$LOG_CONTENT" ]; then
            LOG_CONTENT="* 本次推送没有包含新的代码提交。"
          fi
          
          # 3. 使用多行语法将日志内容写入 GITHUB_OUTPUT
          {
            echo 'changelog<<EOF'
            echo "$LOG_CONTENT"
            echo 'EOF'
          } >> "$GITHUB_OUTPUT"

      # 第八步：创建 GitHub Release 并上传构建产物
      - name: Create Release and Upload Asset
        uses: softprops/action-gh-release@v2
        with:
          body: |
            ## 自动构建产物

            **✨ 本次更新包含以下提交:**
            ${{ steps.generate_notes.outputs.changelog }}
            
          # 使用新版本号来命名 tag 和 release title
          tag_name: v${{ env.NEW_VERSION }}
          name: Auto Build - v${{ env.NEW_VERSION }}
          prerelease: true
          # 使用通配符来匹配包含版本号的 zip 文件，更具鲁棒性
          # 假设您的构建产物文件名中包含了版本号，如 IntelliJ-EmmyLua-1.1.0-IDEA251.zip
          files: build/distributions/*.zip

      # 第九步：更新版本跟踪文件并提交回仓库
      # 这是实现版本持久化的关键
      - name: Update and Commit Version Tracking File
        run: |
          # 1. 创建或覆盖版本跟踪文件
          echo "LAST_VERSION=${{ env.NEW_VERSION }}" > version.properties
          echo "LAST_COMMIT=${{ github.sha }}" >> version.properties
          echo "LAST_RELEASE_DATE=$(date +'%Y-%m-%d')" >> version.properties
          
          echo "新的版本跟踪文件内容:"
          cat version.properties

          # 2. 配置 git 用户
          git config --local user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          
          # 3. 添加更改并提交
          git add version.properties plugin.xml
          # 使用 [skip ci] 来防止本次提交触发新的工作流，避免无限循环
          git commit -m "chore(release): 自动更新版本至 ${{ env.NEW_VERSION }}" -m "[skip ci]"
          
          # 4. 推送回 main 分支
          git push
