#
# Copyright (c) 2017. tangzx(love.tangzx@qq.com)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
livetemplate.description.func=function functionName() end
livetemplate.description.lfunc=local function functionName() end
livetemplate.description.closure=function() end
livetemplate.description.for-loop=for i = 1, 10 do end
livetemplate.description.if-end=if expr then end
livetemplate.description.if-else=if expr then else end
livetemplate.description.else-if=elseif expr then
livetemplate.description.for-i=for i, v in ipairs(expr) do end
livetemplate.description.for-p=for k, v in pairs(expr) do end
livetemplate.description.param_sig=参数签名
inspection.duplicate_class=在文件中发现重复的类: {0}
inspection.empty_for=空的for循环体
inspection.empty_do=空的do语句体
inspection.empty_while=空的while循环体
run.attach.start_info=尝试附加到 \"{0}\" 进程ID:{1} 使用 {2} 调试器。
run.attach.launch_info=尝试启动程序:{0} 使用 {1} 调试器。
ui.luacheck.command_line=命令行
ui.luacheck.name=LuaCheck
ui.luacheck.download=下载 LuaCheck
ui.luacheck.command_line_options=命令行选项
ui.settings.constructor_names=构造函数名称(&C):
ui.settings.strict_doc=严格文档(&D)
ui.settings.smart_close_end=智能关闭 'end'(&S)
ui.settings.recognize_global_name_as_type=将全局名称识别为类型
ui.settings.enable_generic=启用泛型
ui.settings.additional_root=Lua 附加源码根目录
ui.settings.show_words=在文件中显示单词(&W)
ui.settings.type_safety=类型安全
ui.settings.enforce_type_safety=强制类型安全
ui.settings.strict_nil_checks=严格nil检查
ui.settings.require_like_function_names=类似require的函数名称(&R):
action.sort.alphabetically=按字母顺序排序
action.sort.alphabetically_desc=按字母顺序排序

# 代码风格设置
codestyle.spacing.table=表格
codestyle.spacing.table.around_assign=赋值操作符周围
codestyle.spacing.table.around_comma=表格中逗号周围
codestyle.spacing.table.inside_inline=内联表格内部
codestyle.spacing.table.between_fields=表格字段之间
codestyle.spacing.binary_operator=二元操作符周围
codestyle.spacing.function_call=函数调用间距
codestyle.spacing.function_call.around_parentheses=函数调用中括号周围
codestyle.spacing.function_call.within_parentheses=函数调用括号内
codestyle.spacing.function_call.around_comma=函数调用中逗号周围
codestyle.spacing.comment=注释间距
codestyle.spacing.comment.before_line=行注释前
codestyle.spacing.comment.after_line=行注释后

codestyle.blank_lines.require=Require语句
codestyle.blank_lines.require.before=require语句前
codestyle.blank_lines.require.after=require块后
codestyle.blank_lines.function=函数
codestyle.blank_lines.function.before=函数前
codestyle.blank_lines.function.after=函数后

codestyle.wrapping.table=表格对齐
codestyle.wrapping.table.align_fields=对齐表字段
codestyle.wrapping.table.align_assign=对齐等号
codestyle.wrapping.table.wrap_after_comma=逗号后换行
codestyle.wrapping.comment=注释对齐
codestyle.wrapping.comment.align_line=对齐行注释
codestyle.wrapping.loop=循环语句对齐
codestyle.wrapping.loop.align_body=对齐循环体
codestyle.wrapping.function_call=函数调用对齐
codestyle.wrapping.function_call.align_parameters=对齐函数参数
codestyle.wrapping.function_call.wrap_after_comma=函数调用中逗号后换行
codestyle.wrapping.variable=变量声明
codestyle.wrapping.variable.alignment=变量对齐
codestyle.variable.alignment.do_not_align=不对齐
codestyle.variable.alignment.align_all=按列对齐变量
codestyle.variable.alignment.align_contiguous=对齐连续块中的变量

# Action texts
action.copy_lua_require_path=复制Lua Require路径
action.copy_lua_relative_path=复制Lua相对路径

# Debugger settings
debugger.stop_on_entry=入口处停止
debugger.use_c_hook=使用C Hook
debugger.transport_type=传输类型:
debugger.host=主机:
debugger.port=端口:
debugger.log_level=日志级别:
debugger.transport.tcp_client=TCP客户端
debugger.transport.tcp_server=TCP服务器
plugin.description.chinese_community=中国朋友可以加QQ群9850775交流及反馈BUG

# 调试日志消息
debug.log.debug=调试日志
debug.log.connection=连接状态日志
debug.log.error=错误日志
debug.log.tcp_client_connect=TCP客户端连接 {0}:{1}
debug.log.tcp_server_listen=TCP服务器监听端口 {0}
debug.log.receive_protocol=接收协议: {0}
debug.log.send_protocol=发送协议: {0}
debug.log.parse_failed=消息解析失败: {0}
debug.log.send_failed=消息发送失败: {0}
debug.log.connection_lost=检测到连接断开
debug.log.client_connected=客户端已连接: {0}
debug.log.client_disconnected=检测到客户端断开连接
debug.log.server_start_failed=TCP服务器启动失败: {0}
debug.log.server_close_failed=TCP服务器关闭异常: {0}
debug.log.client_close_failed=TCP客户端关闭异常: {0}

# 调试进程消息
debug.session_initialized=调试会话初始化完成
debug.transport_info=设置传输器: {0}
debug.connection_status=连接状态: {0}
debug.connected=已连接
debug.disconnected=已断开
debug.transport_start_failed=传输器启动失败: {0}
debug.plugin_path=插件路径: {0}
debug.plugin_descriptor_null=插件描述符为null
debug.get_plugin_path_failed=获取插件路径失败: {0}
debug.init_complete=初始化完成 - HookLib:{0}, Loadstring:{1}, B64:{2}
debug.send_breakpoints=发送现有断点: {0}个
debug.connection_lost_stop=连接断开，停止调试会话
debug.session_stopped=调试会话已停止
debug.stop_session_error=停止调试会话时出错: {0}
debug.no_stack_info=警告：消息中没有找到堆栈信息
debug.step_over_to=单步跳过到
debug.step_in_to=单步进入到
debug.step_out_to=单步跳出到
debug.breakpoint_hit=断点命中
debug.action_info={0}: {1}:{2} ({3}个堆栈帧)
debug.lua_program_stopped=收到Lua程序停止运行命令
debug.set_breakpoint=设置断点: {0}:{1}
debug.remove_breakpoint=移除断点: {0}:{1}
debug.continue_run=继续运行
debug.stop_debug=停止调试
debug.stop_confirm_received=收到停止确认，关闭连接
debug.stop_confirm_timeout=停止确认超时，强制关闭连接
debug.send_stop_error=发送停止命令时出错: {0}
debug.transporter_null=transporter为null，无法发送stopRun命令
debug.step_over=单步跳过
debug.step_in=单步进入
debug.step_out=单步跳出

# 求值器消息
eval.failed_parse_response=求值失败：无法解析响应
eval.failed_error=求值失败：{0}

# 挂起上下文消息
suspend.parse_stack_failed=解析栈帧变量响应失败: {0}
suspend.parse_variable_failed=解析getVariable响应失败: {0}

# 提取函数重构
refactor.extract_method.title=提取函数
refactor.extract_method.action_name=提取函数
refactor.extract_method.action_description=将选中的代码提取为新函数
refactor.extract_method.dialog.function_name=函数名:
refactor.extract_method.dialog.input_parameters=输入参数:
refactor.extract_method.dialog.return_values=返回值:
refactor.extract_method.dialog.description=将选中的代码提取为独立函数。<br>输入参数：在提取代码中使用但未定义的变量<br>返回值：在提取代码中定义且在外部使用的变量
refactor.extract_method.validation.empty_name=函数名不能为空
refactor.extract_method.validation.invalid_identifier=函数名必须是有效的Lua标识符
refactor.extract_method.validation.invalid_selection=选择的代码不能提取为函数
refactor.extract_method.validation.no_selection=请选择要提取为函数的代码块
refactor.extract_method.validation.cannot_determine_range=无法确定选择的代码范围
refactor.extract_method.parameter_prefix=参数: {0}
refactor.extract_method.return_value_prefix=返回值: {0}